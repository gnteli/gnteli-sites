<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>blah</title>

  <!-- Google Fonts (molto diversi) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bungee&family=Monoton&family=Press+Start+2P&family=Pacifico&family=Black+Ops+One&family=Rubik+Wet+Paint&family=Orbitron:wght@700&family=Playfair+Display:wght@900&family=Permanent+Marker&family=Bebas+Neue&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    #rig{
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      will-change: transform;
      pointer-events: none;
    }

    #ascii{
      margin: 0;
      white-space: pre;
      line-height: 1;
      text-align: center;
      user-select: none;

      font-size: clamp(14px, 2.0vw, 26px);

      transform: translateY(0px) scale(1);
      will-change: transform;
    }
  </style>
</head>
<body>

  <div id="rig">
    <pre id="ascii"></pre>
  </div>

  <audio id="audio" src="blamp4.mp3" preload="auto" crossorigin="anonymous"></audio>

  <script>
    const audio = document.getElementById("audio");
    const rig = document.getElementById("rig");
    const asciiEl = document.getElementById("ascii");

    // ===== Web Audio (AnalyserNode) =====
    let ctx = null, analyser = null, srcNode = null, freqData = null;

    function setupAudio(){
      if (ctx) return;
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = ctx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.85;
      freqData = new Uint8Array(analyser.frequencyBinCount);

      srcNode = ctx.createMediaElementSource(audio);
      srcNode.connect(analyser);
      analyser.connect(ctx.destination);
    }

    const SETTINGS = {
      volumeGain: 1.75,

      maxScaleAdd: 0.35,
      peakZoomBigMax: 1.55,
      peakZoomResetMax: 0.10,
      peakZoomDecay: 0.82,

      maxBouncePx: 62,

      cellMin: 6,
      cellMax: 14,

      peakThreshold: 0.22,
      peakRise: 0.030,
      peakCooldownMs: 260,

      // ✅ Margine richiesto: 10px per lato
      screenPadding: 10,

      moveEase: 0.12,
      moveMaxStep: 40,

      moveMinRadius: 70,
      moveMaxRadius: 280,
      peakStrengthGain: 3.0
    };

    function getEnergy01(){
      analyser.getByteFrequencyData(freqData);
      let sumSq = 0;
      for (let i = 0; i < freqData.length; i++){
        const v = freqData[i] / 255;
        sumSq += v * v;
      }
      const rms = Math.sqrt(sumSq / freqData.length);
      return Math.min(1, Math.max(0, rms * SETTINGS.volumeGain));
    }

    // ===== Font Google =====
    const FONTS = [
      '"Monoton", system-ui, sans-serif',
      '"Bungee", system-ui, sans-serif',
      '"Press Start 2P", system-ui, sans-serif',
      '"Pacifico", system-ui, sans-serif',
      '"Black Ops One", system-ui, sans-serif',
      '"Rubik Wet Paint", system-ui, sans-serif',
      '"Orbitron", system-ui, sans-serif',
      '"Playfair Display", serif',
      '"Permanent Marker", system-ui, sans-serif',
      '"Bebas Neue", system-ui, sans-serif'
    ];
    const pickRandom = (arr) => arr[(Math.random() * arr.length) | 0];
    function pickDifferentFont(notThis){
      if (FONTS.length < 2) return notThis;
      let f = pickRandom(FONTS);
      let guard = 0;
      while (f === notThis && guard++ < 20) f = pickRandom(FONTS);
      return f;
    }
    let initialFont = pickRandom(FONTS);
    let currentFont = initialFont;

    // ===== ASCII numeri =====
    const DIGITS = "0123456789";
    const WORD = "blah";

    const cvs = document.createElement("canvas");
    const g = cvs.getContext("2d", { willReadFrequently: true });

    function lumAt(img, W, x, y){
      const idx = (y * W + x) * 4;
      const r = img[idx], gg = img[idx+1], b = img[idx+2];
      return (r + gg + b) / (3 * 255);
    }
    function hash2(x, y){
      let n = (x * 374761393 + y * 668265263) | 0;
      n = (n ^ (n >>> 13)) | 0;
      n = (n * 1274126177) | 0;
      return ((n ^ (n >>> 16)) >>> 0) / 4294967296;
    }

    function renderASCII(cellSize, fontFamily, t, energy){
      const W = 1020, H = 340;
      if (cvs.width !== W) { cvs.width = W; cvs.height = H; }

      g.fillStyle = "#000";
      g.fillRect(0,0,W,H);

      g.fillStyle = "#fff";
      g.textAlign = "center";
      g.textBaseline = "middle";
      g.font = `900 260px ${fontFamily}`;
      g.fillText(WORD, W/2, H/2);

      const img = g.getImageData(0,0,W,H).data;

      const cell = cellSize;
      const stepX = Math.max(2, Math.round(cell * 1.18));
      const stepY = Math.max(2, cell);

      const flow = t * (1.15 + energy * 0.7);
      const jitterAmp = (0.45 + energy * 0.9);

      let out = "";
      for (let y = 0; y < H; y += stepY){
        for (let x = 0; x < W; x += stepX){
          let cx = x + (stepX >> 1);
          let cy = y + (stepY >> 1);
          if (cx > W-2) cx = W-2;
          if (cy > H-2) cy = H-2;

          const baseLum = lumAt(img, W, cx, cy);
          if (baseLum < 0.08) { out += " "; continue; }

          const h = hash2((x/stepX)|0, (y/stepY)|0);
          const jx = (Math.sin(flow + h * 6.283) * jitterAmp * stepX) | 0;
          const jy = (Math.cos(flow * 0.9 + h * 6.283) * jitterAmp * stepY) | 0;

          const sx = Math.max(0, Math.min(W-2, cx + jx));
          const sy = Math.max(0, Math.min(H-2, cy + jy));

          const lum = lumAt(img, W, sx, sy);
          const l1 = lumAt(img, W, Math.min(W-2, sx+1), sy);
          const l2 = lumAt(img, W, sx, Math.min(H-2, sy+1));
          const grad = Math.abs(lum - l1) + Math.abs(lum - l2);
          const isEdge = grad > 0.33;

          const timeSpin = (t * 8.0 + h * 10.0) % 10;
          const lumIdx = Math.round(lum * 9);

          let digitIndex;
          if (isEdge) digitIndex = Math.max(lumIdx, 6);
          else digitIndex = (Math.floor(timeSpin + lumIdx) % 10);

          out += DIGITS[digitIndex];
        }
        out += "\n";
      }
      asciiEl.textContent = out.trimEnd();
    }

    // ===== Movimento controllato con clamp “vero” sullo schermo =====
    let curX = 0, curY = 0;
    let tgtX = 0, tgtY = 0;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // misura il bounding box reale del rig DOPO aver applicato lo scale corrente
    function clampToViewport(x, y, scale){
      // prima applico temporaneamente il transform del rig (senza toccare ascii scale)
      // per misurare bene uso una misura basata su dimensioni attuali del rig * scale.
      const rect = rig.getBoundingClientRect();

      // rect è già in coordinate viewport col rig attuale: usiamo width/height non scalate dal rig,
      // quindi stimiamo la dimensione effettiva includendo lo scale dell'ASCII:
      const w = rect.width * scale;
      const h = rect.height * scale;

      const pad = SETTINGS.screenPadding;
      const maxX = Math.max(0, (window.innerWidth  / 2) - (w/2) - pad);
      const maxY = Math.max(0, (window.innerHeight / 2) - (h/2) - pad);

      return {
        x: clamp(x, -maxX, +maxX),
        y: clamp(y, -maxY, +maxY),
      };
    }

    function setRigTransform(x, y){
      rig.style.transform = `translate(calc(-50% + ${x.toFixed(1)}px), calc(-50% + ${y.toFixed(1)}px))`;
    }

    function pickTargetOnPeak(peakStrength01, scale){
      const r = SETTINGS.moveMinRadius + (SETTINGS.moveMaxRadius - SETTINGS.moveMinRadius) * peakStrength01;
      const a = Math.random() * Math.PI * 2;

      const rawX = curX + Math.cos(a) * r;
      const rawY = curY + Math.sin(a) * r;

      const cl = clampToViewport(rawX, rawY, scale);
      tgtX = cl.x;
      tgtY = cl.y;
    }

    // ===== Picchi + alternanza zoom =====
    let lastE = 0;
    let lastPeakAt = 0;
    let peakZoomBoost = 0;
    let nextPeakIsBig = true;

    function onPeak(e, de, currentScale){
      currentFont = pickDifferentFont(currentFont);

      const strength = clamp(
        e * 0.6 + clamp(de * SETTINGS.peakStrengthGain, 0, 1) * 0.7,
        0, 1
      );

      // alternanza zoom
      if (nextPeakIsBig) {
        peakZoomBoost = Math.max(peakZoomBoost, strength * SETTINGS.peakZoomBigMax);
      } else {
        peakZoomBoost = Math.min(peakZoomBoost, strength * SETTINGS.peakZoomResetMax);
      }
      nextPeakIsBig = !nextPeakIsBig;

      // target clampato considerando scala (così non esce fuori)
      pickTargetOnPeak(strength, currentScale);
    }

    // ===== Animazione =====
    let running = false;
    let raf = 0;
    let phase = 0;

    function tick(){
      if (!running) return;

      const t = audio.currentTime || 0;

      if (analyser && !audio.paused){
        const e = getEnergy01();
        const de = e - lastE;
        lastE = e;

        // zoom base + spike
        peakZoomBoost *= SETTINGS.peakZoomDecay;
        const scale = 1 + (e * SETTINGS.maxScaleAdd) + peakZoomBoost;

        const now = performance.now();
        const isPeak =
          (e > SETTINGS.peakThreshold) &&
          (de > SETTINGS.peakRise) &&
          (now - lastPeakAt > SETTINGS.peakCooldownMs);

        if (isPeak){
          lastPeakAt = now;
          onPeak(e, de, scale);
        }

        // easing verso target
        const dx = (tgtX - curX) * 0.12;
        const dy = (tgtY - curY) * 0.12;

        curX += clamp(dx, -40, 40);
        curY += clamp(dy, -40, 40);

        // clamp finale anche mentre ci muoviamo (sicurezza extra)
        const cl = clampToViewport(curX, curY, scale);
        curX = cl.x;
        curY = cl.y;

        setRigTransform(curX, curY);

        // bounce
        phase += 0.18 + e * 0.45;
        const bounce = Math.max(0, Math.sin(phase)) * (e * SETTINGS.maxBouncePx);
        const y = -bounce;

        asciiEl.style.transform = `translateY(${y.toFixed(1)}px) scale(${scale.toFixed(3)})`;

        // ASCII detail
        const cell = Math.round(SETTINGS.cellMax - (SETTINGS.cellMax - SETTINGS.cellMin) * e);
        renderASCII(cell, currentFont, t, e);
      }

      raf = requestAnimationFrame(tick);
    }

    // ===== Controllo: SOLO barra spaziatrice =====
    async function toggleWithSpace(){
      setupAudio();
      if (ctx.state === "suspended") await ctx.resume();

      if (document.fonts && document.fonts.ready) {
        try { await document.fonts.ready; } catch {}
      }

      if (!audio.paused) {
        audio.pause();
        running = false;
        if (raf) cancelAnimationFrame(raf);
        return;
      }

      await audio.play();
      running = true;

      // clamp iniziale con margine 10px
      const cl = clampToViewport(curX, curY, 1);
      curX = cl.x; curY = cl.y;
      tgtX = curX; tgtY = curY;
      setRigTransform(curX, curY);

      tick();
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        toggleWithSpace().catch(console.warn);
      }
    }, { passive: false });

    // init
    setRigTransform(0, 0);
    (async () => {
      if (document.fonts && document.fonts.ready) {
        try { await document.fonts.ready; } catch {}
      }
      renderASCII(10, currentFont, 0, 0);
      asciiEl.style.transform = `translateY(0px) scale(1)`;
    })();

    window.addEventListener("resize", () => {
      const cl = clampToViewport(curX, curY, 1);
      curX = cl.x; curY = cl.y;
      tgtX = clampToViewport(tgtX, tgtY, 1).x;
      tgtY = clampToViewport(tgtX, tgtY, 1).y;
      setRigTransform(curX, curY);
    });

    // fine traccia: reset scala a 1 + font diverso
    audio.addEventListener("ended", async () => {
      running = false;
      if (raf) cancelAnimationFrame(raf);

      peakZoomBoost = 0;
      phase = 0;
      curX = 0; curY = 0; tgtX = 0; tgtY = 0;

      setRigTransform(0, 0);
      currentFont = pickDifferentFont(initialFont);

      if (document.fonts && document.fonts.ready) {
        try { await document.fonts.ready; } catch {}
      }
      renderASCII(10, currentFont, 0, 0);
      asciiEl.style.transform = `translateY(0px) scale(1)`;
    });

    audio.addEventListener("error", () => {
      console.warn("Audio non trovato: controlla il nome del file in src.");
    });
  </script>
</body>
</html>